1. Используя creat(), write(), fflush(), close(), gettimeofday(), разработать программу, которая
открывает файл,
записывает туда 300 KB,
очищает все записи,
закрывает и
удаляет файл,
а также измеряет и выводит время, затраченное на каждое действие.

- lab5

Системный вызов  creat()  либо создает  новый файл,
либо открывает и чистит существующий.  Pmode задает
режимы чтения-записи файла в дальнейшем, после пер-
вого закрытия.

write записывает до count байтов из буфера buf в файл, на который ссылается файловый описатель fd.
В случае успешного завершения возвращается количество байтов, которые были записаны.
Если stream связан с файлом, открытым для записи, то вызов fflush() приводит к физической записи содержимого буфера в файл. Если же stream указывает на вводимый файл, то очищается входной буфер
  
unlink удаляет файл,  определяемый строкой имени файла. Unlink возвращает 0 в случае успешного удаления файла,
      либо -1 в случае возникновения ошибки; 
      
2. Разработать программу, которая замеряет время для 300,000 однобайтовых записей с использованием
a) напрямую POSIX: creat(), write(), close().
b) с использованием библиотеки stdio (напр., fopen(), fwrite(), and fclose()).
Сравнить и объяснить результаты.

- lab5

fwrite работает с потоками, которые буферизируются. 
Поэтому запись многих небольших буферов будет работать быстрее - они не будут выполнять дорогостоящий системный вызов, 
пока буфер не заполнится. С другой стороны, небольшие буферы, отправляемые на запись, будут выполнять дорогостоящий системный
вызов для каждого буфера. Для больших буферов разница будет небольшой, потому что будет меньше буферизации и, следовательно,
более согласованное количество системных вызовов между fwrite и write.

3. Разработать собственную версию (mytail) команды tail.
Формат: mytail -n file
Она читает блок из конца файла, просматривает его с конца до заданного количества строк n и печатает эти строки
в соответствующем порядке.
Использовать: stat(), lseek(), open(), read(), close(), ...

- mytail

stat возвращает информацию о файле file_name и заполняет буфер buf. 
                                 
                     st_mode              Битовая  маска  для информации о режиме
                                          файла.  Бит   S_IFDIR  устанавливается,
                                          если  pathname  определяет  директорий;
                                          бит   S_IFREG   устанавливается,   если
                                          pathname  ссылается  на  обычный  файл.
                                          Биты   чтения/записи    устанавливаются
                                          пользователем в соответствии с  режимом
                                          доступа к файлу. Пользователь выполняет
                                          установку битов, используемых для  рас-
                                          ширения имени файла.

                     st_dev               Номер   устройства  диска,  содержащего
                                          файл.

                     st_rdev              Номер   устройства  диска,  содержащего
                                          файл.
                                          (аналогично st_dev).

                     st_nlink             Всегда 1.

                     st_size              Размер файла  в байтах.

                     st_atime             Время последней модификации файла.

                     st_mtime             Время последней модификации файла
                                          (аналогично st_atime).

                     st_ctime             Время последней модификации файла
                                          (аналогично st_atime и st_mtime).
                      
                      
4. Разработать собственную версию (mystat) команды stat, которая просто осуществляет системный вызов stat(), выводит
размер, число задействованных блоков, число жестких ссылок и т. д. Отследить, как меняется число ссылок при их добавлении/удалении.

Имя файла, ссылающееся на его индексный дескриптор, называется жесткой ссылкой. Механизм жестких ссылок – это основной способ обращаться к файлу в Unix-подобных операционных системах
 вся информация о файле привязана не к его имени, а так называемому числовому индексному дескриптору. У каждого файла есть свой уникальный индексный дескриптор, к которому привязаны сведения об этом файле: в каких блоках диска хранится его содержимое, размер, время создания, модификации и др.

- mystat

Индексные дескрипторы файлов хранятся в специальной таблице. Каждый логический и физический диск имеет собственную таблицу дескрипторов.

Именно номер индекса является истинным именем файла в системе. Мы можем их увидеть с помощью ключа -i команды ls.
Жесткая ссылка работает как зеркальная копия оригинального файла. Эти ссылки используют одни и те же индексные дескрипторы (иноды). Изменения в одном из файлов, связанных жесткой ссылкой, отразятся в другом. При удалении жесткой ссылки с другим файлом ничего не произойдет. Жесткие ссылки не могут связывать различные файловые системы. Синтаксис для создания жесткой ссылки следующий

        ln <источник> <ссылка>
        
5. Разработать собственную версию (myls) команды ls, которая выводит список файлов в заданной директории.
С ключом -l она выводит информацию о каждом файле, включая собственника, группу, разрешения и т.д., получаемые из системного
вызова stat().
Формат: myls -l directory (или текущую директорию, если параметр не задан)
Использовать: stat(), opendir(), readdir(), getcwd(), ...

- myls

Директория сама по себе представляет файл состоящий из специальных записей dirent, которые содержат данные о файлах в директории
Данная структура содержит имя файла d_name, порядковый номер файла d_ino в файловой системе и несколько других.
Для работы с директориями необходимо определить переменную типа DIR
Функция opendir() открывает директорию для чтения с именем name и возвращает указатель на directory stream, при ошибке возвращает NULL и соответствующим образом устанавливает код ошибки errno. Функция closedir() соответсвенно закрывает ее.
функция readdir() возвращает следующую структуру dirent считанную из файла-директории. При достижении конца списка файлов в директории или возникновении ошибки возвращает NULL.



6. Разработать программу, которая выводит имена каждого файла и директории, начиная с заданной точки в дереве каталогов.
a) Без аргументов: сначала текущая директория и ее содержимое, затем поддиректории и т.д. (пока не закончится дерево,
root в качестве CWD).
b) С одним аргументом (который есть имя директории): все поддерево, начиная с заданной директории.
c) А также еще один какой-либо интересный вариант (см. опции для find).

- myfind
