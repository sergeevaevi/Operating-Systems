Проверка целостности данных

Контро́льная су́мма — некоторое значение, рассчитанное по набору данных путём применения определённого алгоритма и используемое для проверки целостности данных при их передаче или хранении. Также контрольные суммы могут использоваться для быстрого сравнения двух наборов данных на неэквивалентность: с большой вероятностью различные наборы данных будут иметь неравные контрольные суммы. Это может быть использовано, например, для обнаружения компьютерных вирусов. Несмотря на своё название, контрольная сумма не обязательно вычисляется путём суммирования.

1. Разработать программу (check-xor.c), которая вычисляет с использованием XOR и выводит контрольную сумму для входных файлов. 
Использовать 8-битный символ без знака (1 байт) под эту сумму. 
Продемонстрировать работу на тестах (тест=входные данные, для которых правильный результат известен заранее, т.е. данные и ожидаемый результат), подготовленных систематически.


2. Разработать аналогичную программу (check-fletcher.c), которая вычисляет и выводит контрольную сумму Флетчера ( the Fletcher checksum) для входных файлов. 
Продемонстрировать работу на тестах (тест=входные данные, для которых правильный результат известен заранее, т.е. данные и ожидаемый результат), подготовленных систематически.

- Контрольная сумма Флетчера — это алгоритм вычисления контрольной суммы
, разработанной Джоном Флетчером. Цель контрольной суммы Флетчера заключалась в том, чтобы обеспечить обнаружение ошибок,
близкое к свойствам циклического избыточного кода, но с более низкой вычислительной сложностью.
Когда слово данных разделяется на 8-битные блоки, как в приведённом выше примере, две 8-битной суммы объединяются в 16-битную контрольную сумму Флетчера.
Как и в случае с более простыми алгоритмами контрольных сумм, контрольная сумма Флетчера включает в себя разделение двоичного слова, которое должно быть проверено на ошибки, на короткие «блоки» бит и вычисление суммы по модулю для этих блоков. 
Очевидно, что выбор модуля должен быть таким, чтобы результаты соответствовали размеру блока. 256, следовательно, является самым большим возможным модулем для Fletcher-16. 

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/test_fl.png)

3. Разработать аналогичную программу (crc.c), которая вычисляет и выводит 16-битный циклический избыточный код (the 16-bit CRC).
Продемонстрировать работу на тестах (тест=входные данные, для которых правильный результат известен заранее, т.е. данные и ожидаемый результат), подготовленных систематически.

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/crc.png) 

- Одним из основных параметров CRC является порождающий полином.

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/ccitt.png)

С порождающим полиномом связан другой параметр — его степень, которая определяет количество битов, используемых для вычисления значения CRC. На практике наиболее распространены 8-, 16- и 32-битовые слова, что является следствием особенностей архитектуры современной вычислительной техники.
 Из файла берётся первое слово — это может быть битовый (CRC-1), байтовый (CRC-8) или любой другой элемент. Если старший бит в слове «1», то слово сдвигается влево на один разряд с последующим выполнением операции XOR c порождающим полиномом. Соответственно, если старший бит в слове «0», то после сдвига операция XOR не выполняется. После сдвига теряется старший бит, а младший бит освобождается — его значение устанавливается равным нулю. На место младшего бита загружается очередной бит из файла, и операция повторяется до тех пор, пока не загрузится последний бит файла. После прохождения всего файла, в слове остается остаток, который и является контрольной суммой.

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/crc1.png)
![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/crc2.png)
![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/crc3.png)

4. Сравнить время работы (gettimeofday) программ из 1, 2 и 3 на входных файлах различных размеров.
Какая предпочтительнее с точки зрения времени и качества проверки?
Продемонстрировать работу на тестах (тест=входные данные, для которых правильный результат известен заранее, т.е. данные и ожидаемый результат), подготовленных систематически.
- Флетчер работает лучше моего варианта CRC - последний имеет большую вычислительную сложность, хотя эффективность флетчера не уступает CRC. Самым простым оказался XOR, но он дае большое число коллизий.

5. Разработать программу (create-csum.c), которая вычисляет однобайтовые контрольные суммы для каждого 4KB блока входного файла и сохраняет их в контрольном файле,
а также программу (check-csum.c), которая читает файл, также вычисляет однобайтовые контрольные суммы для каждого 4KB блока и сравнивает их с заранее вычисленными значениями из контрольного файла. 
Если обнаруживаются расхождения,то выводятся соответствующие сообщения. 
Продемонстрировать работу на тестах (тест=входные данные, для которых правильный результат известен заранее, т.е. данные и ожидаемый результат), подготовленных систематически.
- Расхождения вышло сделать только изменив файл
