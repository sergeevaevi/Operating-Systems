	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>

	int
	main(int argc, char *argv[])
	{
		printf("hello world (pid:%d)\n", (int) getpid());
		int rc = fork();
		if (rc < 0) {
			// fork failed; exit
			fprintf(stderr, "fork failed\n");
			exit(1);
		} else if (rc == 0) {
			// child (new process)
			printf("hello, I am child (pid:%d)\n", (int) getpid());
		} else {	
			// parent goes down this path (original process)
			printf("hello, I am parent of %d (pid:%d)\n",
			rc, (int) getpid());
		}
		return 0;
	}
В первую очередь мы входим в функцию main() и выполняем вывод строки на экран. Строка содержит идентификатор процесса который называется PID. Следующей командой будет выполнен вызов fork(). В этот момент создается практически точная копия процесса. Вновь созданные процесс-потомок (по отношению к создавшему его процессу-родителю) уже не будет выполняться, начиная с функции main(). Следует помнить, что процесс-потомок не является точной копией процесса-родителя, в частности у него есть собственное адресное пространство, собственные регистры, свой указатель на исполняемые инструкции и тому подобное. Таким образом, значение, возвращаемое вызывателю функции fork() будет разным. В частности, процесс-родитель получит в качестве возврата значение PID процесса ребенка, а ребенок получит значение равное 0. По этим кодам возврата в дальнейшем уже можно разделять процессы и заставлять каждый из них выполнять свою работу. При этом выполнение данной программы не определено строго.
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/wait.h>

	int
	main(int argc, char *argv[])
	{
	    printf("hello world (pid:%d)\n", (int) getpid());
	    int rc = fork();
	    if (rc < 0) {
		// fork failed; exit
		fprintf(stderr, "fork failed\n");
		exit(1);
	    } else if (rc == 0) {
		// child (new process)
		printf("hello, I am child (pid:%d)\n", (int) getpid());
		sleep(1);
	    } else {
		// parent goes down this path (original process)
		int wc = wait(NULL);
		printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
		       rc, wc, (int) getpid());
	    }
	    return 0;
	}
За счет наличия вызова wait() процесс-родитель всегда будет дожидаться завершения работы процесса-потомка. В этом случае мы получим строго определенный вывод текста на экран.
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <string.h>
	#include <sys/wait.h>

	int
	main(int argc, char *argv[])
	{
	    printf("hello world (pid:%d)\n", (int) getpid());
	    int rc = fork();
	    if (rc < 0) {
		// fork failed; exit
		fprintf(stderr, "fork failed\n");
		exit(1);
	    } else if (rc == 0) {
		// child (new process)
		printf("hello, I am child (pid:%d)\n", (int) getpid());
		char *myargs[3];
		myargs[0] = strdup("wc");   // program: "wc" (word count)
		myargs[1] = strdup("p3.c"); // argument: file to count
		myargs[2] = NULL;           // marks end of array
		execvp(myargs[0], myargs);  // runs word count
		printf("this shouldn't print out");
	    } else {
		// parent goes down this path (original process)
		int wc = wait(NULL);
		printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
		       rc, wc, (int) getpid());
	    }
	    return 0;
	}
Системный вызов exec() полезен, когда мы хотим запустить совершенно другую программу. Здесь мы будем вызывать execvp() для запуска программы wc. Вызову передаются в качестве аргументов имя исполняемого файла и некоторые параметры. После чего происходит загрузка кода и статических данных из этого исполняемого файла и перезатирание собственного сегмента с кодом. Остальные участки памяти, такие как стек и куча переинициализируются. После чего ОС просто исполняет программу, передавая ей набор аргументов. Таким образом, не создавали новый процесс, просто трансформируется текущая запущенная программа в другую запущенную программу.

Unix pipe реализованы похожим образом, с разницей, что они используют вызов pipe(). В этом случае поток вывода процесса будет подключен к очереди pipe, расположенной в ядре к которой же будет присоединен поток ввода другого процесса.

-----------------------------------------------------------------------------------------------------

1. В основной программе переменной x присвоить значение 100, а затем вызвать fork(). Каково значение x в порождённом процессе?
- Так же 100, посколку программа продолжается с сомента вызова fork();

Что происходит, когда основной и порожденный процесы меняют значение x?
- Ничего, в каждом процессе своя переменная x, она и изменится.

2. Порожденный процесс, созданный с помощью fork(), должен напечатать “hello”; основной  -  “goodbye”. Нужно обеспечить, чтобы порожденный процесс печатал первым без использования wait() в основном. 
- p1.c

3. Сначала вызывается fork(), а затем какой-либо вариант  exec() (execl(), execle(), execlp(), execv(), execvp(),
и execvpe()) для вызова  /bin/ls. Для чего предусмотрено столько много вариантов exec()?

-Суффиксы l, v, p и e, добавляемые к имени семейства exec...   обозначают,   что  данная  функция  будет работать с некоторыми особенностями:

p - определяет, что функция будет искать "дочернюю"
программу     в    директориях,    определяемых
переменной среды DOS PATH. Без суффикса p поиск
будет  производиться только в рабочем каталоге.
Если параметр path  не  содержит  маршрута,  то
поиск  производится  в  текущей  директории,  а
затем  по  маршрутaм,  определяемым  переменной
окружения PATH.

l - показывает, что адресные указатели (arg0, arg1,
..., argn) передаются, как отдельные аргументы.
Обычно суффикс l употребляется, когда число передаваемых аргументов заранее вам известно.

v - показывает,  что  адресные  указатели  (arg[0],
arg[1],...arg[n])    передаются,   как   массив
указателей.  Обычно,  суффикс  v  используется,
когда передаeтся переменное число аргументов.

e - показывает, что "дочернему" процессу может быть
передан  аргумент   envp,   который   позволяет
выбирать   среду   "дочернего"   процесса.  Без
суффикса e "дочерний" процесс унаследует  среду
"родительского" процесса.

execl  -  представляет  собой  функцию  семейства
exec...,  которая передает раздельные  аргументы,
ищет "дочерний" процесс только в рабочем каталоге
и  передает  "родительскую"   среду   "дочернему"
процессу.

- execvpe   представляет  собой  функцию  семейства
exec...,  которая  передает   массив   указателей
аргументов, подсоединяет маршрут доступа PATH для
поиска "дочернего" процесса и применяет  аргумент
envp для выбора среды "дочернего" процесса.

4. В основной программе использовать  wait() для того, чтобы дождаться завершения порожденного процесса?

-Функция wait приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится, или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик. Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")), то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются. 
Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию-обработчик. Если указанный дочерний процесс к моменту вызова функции уже завершился, то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются. Параметр pid может принимать несколько значений:
	
	< -1
	означает, что нужно ждать любого дочернего процесса, идентификатор группы процессов которого равен абсолютному значению pid.
	
	-1
	означает ожидание любого дочернего процесса; функция wait ведет себя точно так же.
	
	0
	означает ожидание любого дочернего процесса, идентификатор группы процессов которого равен идентификатору текущего процесса.
	
	> 0
	означает ожидание дочернего процесса, чей идентификатор равен pid.

Что возвращает wait()? 

Возвращает идентификатор дочернего процесса, который завершил выполнение, или ноль, если использовался WNOHANG и ни один дочерний процесс пока еще недоступен, или -1 в случае ошибки (в этом случае переменной errno присваивается соответствующее значение).  

Что произойдет, если использовать wait() в порожденном процессе? Использовать waitpid() вместо of wait(). 

Wait ждет дочерние процессы, поэтому если в порожденнном процессе он будет бесполезен. 
waitpid можно передать с определенными ключами.

Когда использование waitpid() целесообразно?

Системный вызов waitpid() позволяет родительскому процессу ожидать конкретного потомка, а не всех сразу, как это делает wait(). Этот системный вызов принимает в качестве первого аргумента идентификатор процесса, окончание работы которого следует ожидать.

Аргумент EXIT_STATUS имеет тот же смысл, что и в wait(). Третий аргумент позволяет передавать в waitpid() опции, объединяемые операцией побитовой дизъюнкции. Мы будем использовать только одну из возможных опций — WNOHANG, которая
позволяет не блокировать родительский процесс, если потомок еще работает. Если
не требуется передача опций, то в третьем аргументе waitpid() пишут 0.

7. Программа порождает процесс и в нем закрывает стандартный вывод (STDOUT FILENO). Что произойдет, если осуществить вызов printf() для того, чтобы что-то вывести в основном и дочернем процессах?

Если закрыть stdout файл будет невозможно осуществить вывод через printf().

8. Разработать программу, которая создает два порожденных процесса и  соединет стандартный вывод одного со стандартным вводом другого с использованием pipe().

- pipe.c
