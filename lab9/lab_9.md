1. Установить (make) набор программ (см. Makefile) из архива  (см. также http://www.ostep.org).

2. С помощью helgrind (valgrind --tool=helgrind main-race) в программе main-race.c проанализировать ошибки в коде, связанные с несинхронизованностью потоков команд, работающих с общими данными (data race), и попытаться их устранить.

- lab8_1

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/2task_8lab.png)

Это довольно много деталей для простой ошибки. Последнее предложение является основным сообщением об ошибке. 
В нем говорится о гонке в результате чтения размером 4 (байта), который является адресом balance.
Две важные части сообщения: Helgrind показывает две трассировки стека для ошибки, а не одну. 
По определению, в гонке участвуют два разных потока, обращающихся к одному и тому же местоположению таким образом, 
что результат зависит от относительных скоростей двух потоков. 
Первая трассировка стека следует за текстом «Возможная гонка данных при чтении размером 4 ...», 
а вторая трассировка следует за текстом «Это противоречит предыдущей записи размера 4 ...». 
Helgrind обычно способен показать оба доступа, участвующих в гонке. 
Для гонок, которые происходят по глобальным или стековым переменным,
Helgrind пытается идентифицировать имя и определяющую точку переменной.

Способ устранения это мьютекс. Мьютекс – это экземпляр типа pthread_mutex_t. Перед использованием необходимо инициализировать мьютекс функцией pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr) где первый аргумент – указатель на мьютекс, а второй – аттрибуты мьютекса.
Если указан NULL, то используются атрибуты по умолчанию.
В случае удачной инициализации мьютекс переходит в состояние «инициализированный и свободный», 
а функция возвращает 0. Повторная инициализация инициализированного мьютекса приводит к неопределённому поведению.
После использования мьютекса его необходимо уничтожить с помощью функции int pthread_mutex_destroy(pthread_mutex_t *mutex);
В результате функция возвращает 0 в случае успеха или может возвратить код ошибки.
После создания мьютекса он может быть захвачен с помощью функции int pthread_mutex_lock(pthread_mutex_t *mutex);
После этого участок кода становится недоступным остальным потокам – их выполнение блокируется до тех пор, пока мьютекс не будет освобождён. Освобождение должен провести поток, заблокировавший мьютекс, вызовом int pthread_mutex_unlock(pthread_mutex_t *mutex);

3. В программе main-deadlock.c имеется ошибка, называемая мёртвая блокировка (deadlock, ситуация, при которой один поток (поток A), ждет ресурса, удерживаемого другим потоком (потоком B), и при этом удерживает ресурс, который нужен потоку B. Поскольку потоки A и B блокированы в ожидании ресурсов, удерживаемых другим потоком, выполнения не происходит). Использовать helgrind и проинтерпретировать отчет.

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/3task8lab.png)


Helgrind контролирует порядок, в котором потоки получают блокировки. 
Это позволяет обнаруживать потенциальные тупики, которые могут возникнуть в результате образования циклов замков. 
Хелгринд строит ориентированный граф, указывающий порядок, в котором блокировки были получены в прошлом. 
Когда поток получает новую блокировку, график обновляется, а затем проверяется, чтобы увидеть, 
содержит ли он теперь цикл. Наличие цикла указывает на потенциальную тупиковую ситуацию, связанную с блокировками в цикле.
В общем, Helgrind выберет две блокировки, участвующие в цикле, и покажет вам, как их порядок приобретения стал противоречивым.
Это делается путем показа программных точек, которые сначала определили порядок, и программных точек,
которые позже нарушили его.


4. Также использовать helgrind для main-deadlock-global.c и проанализировать отчет, сравнить с предыдущим.


![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/4tasklab8.png)

Однако в настоящее время Helgrind не показывает задействованные блокировки, иногда потому, что эта информация недоступна,
но также во избежание затопления информацией. Поэтому в данном случе он ошибается.

5. В программе main-signal.c переменная (done) используется для того, чтобы обозначить состояние, когда дочерний процесс закончил работу и родительский может продолжить. Проанализировать эффективность и результат работы helgrind на этой программе.

Родительское процесс ждет, проверяя значение done, пока оно не изменится. 
Это тратит время процессора, которое может быть использовано другим процессом.
helgrind сообщает что возможная гонка данных переменной done.
Код на самом деле является потокобезопасным, в данном случае. Но helgrind все же отметит ошибку.

6. Теперь рассмотреть main-signal-cv.c, которая использует условную переменную (condition variable). 
Сравнить с предыдущей. Проанализировать main-signal-cv с использованием helgrind.

Это лучшее решение для нетривиальных программ, поскольку менее вероятно появление ошибок параллелизма при добавлении функций
в механизм сигнализации, и он будет работать лучше.
helgrind не находит ошибок в данном случае.
