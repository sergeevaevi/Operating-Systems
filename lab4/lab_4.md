Использование виртуальной памяти. Выявление ошибок с использованием gdb и valgrind.
1) В программу aspace.c добавить malloc() и выяснить в каком направлении происходит добавление динамической памяти (к старшим адресам). Добавить локальную переменную и проверить то, что в стеке адреса задействуются в сторону убывания. Как найти адрес указателя? Что возвращается при оценивании p и &p? 
Данные запущенного процесса организованы в пять сегментов: 
• Сегмент кода содержит текст программы; то есть инструкции машинного языка, которые составляют программу. 
• Сегмент констант содержит неизменяемые значения, такие как строковые литералы. 
• Глобальный сегмент содержит глобальные переменные и локальные переменные, которые объявлены статическими. 
• Сегмент кучи содержит фрагменты памяти, выделенные во время выполнения, чаще всего путем вызова функции библиотеки C malloc. 
• Сегмент стека содержит стек вызовов, который представляет собой последовательность кадров стека.
Программа acpace.c:
        #include <stdio.h>
        #include <stdlib.h>

        int global;

        void just_func(int n, int *local, void *pointer) {
            void *q = malloc(128);
            double y;
            printf("%p: Address of just_func is \n", just_func);
            printf("%p: Address of y is \n", &y);
            printf("%p: Address of local is \n", local);
            printf("%p: Address of q is \n", q);
            if (&y < local) {
                printf("Stack address is decreasing\n");
            } else {
                printf("Wow! Stack address is increasing\n");
            }
            if (q < pointer) {
                printf("Wow! Heap address is decreasing\n");
            } else {
                printf("Heap address is increasing\n");
            }
        }

        int main() {
            int local = 5;
            void *p = malloc(64);
            printf("%p : address of main is \t\n", main);
            printf("%p: Address of global is \n", &global);
            printf("%p: Address of local is \n", &local);
            just_func(0, &local, p);
            printf("%p: Address of p is   \n", p);
            printf("%p: Address of &p is \n", &p);
            return 0;
        }
       
И вывод данной программы:
![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/output.png)

main - имя функции; используя его как переменную, он будет указывать на адрес первой инструкции машинного языка в main, который мы ожидаем найти в текстовом сегменте. 
global - это глобальная переменная, поэтому она будет в глобальном сегменте. 
local является локальной переменной, поэтому она будет в стеке. 
p указывает на адрес, возвращаемый malloc, который выделяет пространство в куче. 
«malloc» обозначает «выделение памяти». Последовательность форматирования %p указывает printf форматировать каждый адрес как «указатель», чтобы результаты отображались в шестнадцатеричном формате.
Адрес main является самым маленьким. Следующим будет глобальный, затем адрес p. Адрес local намного больше.
Как видно, динамическая память добавляется в сторону увеличения к старшим адресам - то есть куча растет вверх.
Стек, напротив, растет вниз.
Адрес указателя возвражается так же как и адрес переменной, при помощи &.

2) Объяснить поведение фрагмента кода для переменных name и name1

