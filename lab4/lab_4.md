# Использование виртуальной памяти. Выявление ошибок с использованием gdb и valgrind.

1) В программу aspace.c добавить malloc() и выяснить в каком направлении происходит добавление динамической памяти (к старшим адресам). Добавить локальную переменную и проверить то, что в стеке адреса задействуются в сторону убывания. Как найти адрес указателя? Что возвращается при оценивании p и &p? 

Данные запущенного процесса организованы в пять сегментов: 
• Сегмент кода содержит текст программы; то есть инструкции машинного языка, которые составляют программу. 
• Сегмент констант содержит неизменяемые значения, такие как строковые литералы. 
• Глобальный сегмент содержит глобальные переменные и локальные переменные, которые объявлены статическими. 
• Сегмент кучи содержит фрагменты памяти, выделенные во время выполнения, чаще всего путем вызова функции библиотеки C malloc. 
• Сегмент стека содержит стек вызовов, который представляет собой последовательность кадров стека.

- папка с программой lab4

Программа acpace.c:
        #include <stdio.h>
        #include <stdlib.h>

        int global;

        void just_func(int n, int *local, void *pointer) {
            void *q = malloc(128);
            double y;
            printf("%p: Address of just_func is \n", just_func);
            printf("%p: Address of y is \n", &y);
            printf("%p: Address of local is \n", local);
            printf("%p: Address of q is \n", q);
            if (&y < local) {
                printf("Stack address is decreasing\n");
            } else {
                printf("Wow! Stack address is increasing\n");
            }
            if (q < pointer) {
                printf("Wow! Heap address is decreasing\n");
            } else {
                printf("Heap address is increasing\n");
            }
        }

        int main() {
            int local = 5;
            void *p = malloc(64);
            printf("%p : address of main is \t\n", main);
            printf("%p: Address of global is \n", &global);
            printf("%p: Address of local is \n", &local);
            just_func(0, &local, p);
            printf("%p: Address of p is   \n", p);
            printf("%p: Address of &p is \n", &p);
            return 0;
        }
       
И вывод данной программы:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/output.png)

main - имя функции; используя его как переменную, он будет указывать на адрес первой инструкции машинного языка в main, который мы ожидаем найти в текстовом сегменте. 
global - это глобальная переменная, поэтому она будет в глобальном сегменте. 
local является локальной переменной, поэтому она будет в стеке. 
p указывает на адрес, возвращаемый malloc, который выделяет пространство в куче. 
«malloc» обозначает «выделение памяти». Последовательность форматирования %p указывает printf форматировать каждый адрес как «указатель», чтобы результаты отображались в шестнадцатеричном формате.
Адрес main является самым маленьким. Следующим будет глобальный, затем адрес p. Адрес local намного больше.
Как видно, динамическая память добавляется в сторону увеличения к старшим адресам - то есть куча растет вверх.
Стек, напротив, растет вниз.
Адрес указателя возвражается так же как и адрес переменной, при помощи &.

2) Объяснить поведение фрагмента кода для переменных name и name1

        char name[20];
        puts("Enter name: ");
        scanf("%19s", name);
        printf("Hello,  %s.\n\n\tNice to see you.\n", name);

        puts("Enter name: ");
        scanf("%19s", name);
        printf("Hello,  %s.\n\n\tNice to see you.\n", name);


        char *name1="Anna";
        char a_letter=name1[0];
        name1[0]=name1[3];
        name1[3]=a_letter;
        puts(name1);

И вывод данной программы:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/error.png)

name1 относится к «строковому литералу», который является строкой, которая появляется как часть программы (в отличие от строки, которая читается из файла, вводится пользователем и т. д.). Расположение строки находится в постоянном сегменте, тогда как указатель name1, который является локальной переменной.
Поэтому при изменении данных по этому указателю происходит Segmentation fault, то есть обращение с нарушением прав доступа или к несуществующей памяти. 

            char *name1=name;
            char a_letter=name1[0];
            name1[0]=name1[3];
            name1[3]=a_letter;
            puts(name1);
            
Если немного поменять программу, то работа завершается корректно:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/without_error.png)

3) Разработать программу null. c, которая создает указатель на целое и устанавливает его в NULL Затем она пытается получить значение переменной по указателю (dereference). Объяснить результат запуска откомпилированной программы.

- папка с программой null

Указатель NULL указывает на память, которая не существует. Обращение по нулевому указателю является подтипом ошибки, вызывающей ошибку сегментации. Это происходит, когда программа пытается прочитать или записать в память с указателем NULL. Разыменование нулевого указателя может привести к попытке чтения из памяти, что приведет к ошибке сегментации или нарушению доступа к памяти. Поэтому в данной программе возникает Segmentation fault. Хотя стандарт C говорит, что разыменование нулевого указателя является undefined behavior.

4) Откомпилировать null.c с ключом -g, запустить dbg null и вызвать команду run. Объяснить реакцию отладчика. 

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/null_gdb.png)

5) Установить и использовать valgrind (memcheck) для анализа ситуации из 4: valgrind --leak-check=yes null (valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out.txt null). Объяснить результат.

Valgrind хорошо известен как мощное средство поиска ошибок работы с памятью. 
--leak-check
включает (значение yes, summary или full) или отключает (значение no) функцию обнаружения утечек памяти.
--show-leak-types 
Определяет виды утечек, которые будут отображаться при полном поиске утечек
--track-originins
Контролирует, отслеживает ли Memcheck происхождение неинициализированного ценности. При значении Да Memcheck отслеживает происхождение всех неинициализированных значений. 
--verbose
Дает дополнительную информацию о различных аспектах программы.
--log-файл
Указывает, что Valgrind должен отправлять все свои сообщения в указанный файл.
Вывод файла находится в файле. Ошибка в файле:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/null_gdb.png)

Ошибка, когда адрес 0x0 не является стековым, malloc'd или (недавно) free'd и это часто означает разыменование NULL-указателя, что и просходит в программе. 

6) Написать простую программу, которая использует malloc(), но не освобождает память по завершению. Использовать gdb и valgrind для того, чтобы объяснить ошибку.

- папка с программой malloc

При помощи gdb:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/gdb_mem_leak.png)

Моя версия gdb не работает с данными об утечке памяти.

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/ver_gdb.png)

valgrind:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/valgrind_malloc.png)

С помощью valgrind анализировать ошибки памяти намного удобнее. 

7) Написать программу, которая создает массив целых data размера 100, используя malloc(). Установить data[100] в 0. Запустить программу и найти ошибку (если есть) с помощью valgrind.

- папка с программой array_val

В итоге:

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/val_malloc_data.png)
 
Он находит утечку памяти и ошибку в строчке присвоения по сотому адресу массива значения - обращение по чужому адресу. Однако комплятор не выводит сообщения об ошибке.

8) Написать программу, которая создает массив целых (как в 7), освобождает его и пытается напечатать значение какого-либо элемента. Диагностировать ошибку с использованием valgrind.

- папка с программой array_val_free

![Иллюстрация](https://github.com/sergeevaevi/Operating-Systems/raw/master/image/val_malloc_data.png)

Он находит ошибку - обращение по освобожденному адресу. Однако комплятор не выводит сообщения об ошибке.
